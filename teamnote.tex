\documentclass[10pt,landscape,a4paper,twocolumn]{article}

\setlength{\columnsep}{20pt}

\usepackage[left=1.2cm, right=1.2cm, top=1cm, bottom=1.3cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fontspec}
\usepackage{kotex}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{listings}
\usepackage{comment}
\usepackage{import}
\usepackage{wrapfig}
\usepackage{url}
\usepackage{array}
\usepackage[normal]{engord}
\usepackage[svgnames,table]{xcolor}

\setmonofont{Courier}
\setmainhangulfont{NanumMyeongjo}
\setlength\parindent{0pt}
\usepackage[parfill]{parskip}

\definecolor{dkgrey}{RGB}{127, 127, 127}

\lstset{
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    breakindent=1.1em,
%   numbers=left,
%   numberstyle=\footnotesize\ttfamily\color{dkgrey},
%   numbersep=5pt
%   frame=trbl
}


\begin{document}
\tableofcontents


\section{Setting}

\subsection{vimrc}
\lstinputlisting{src/setting/vimrc}


\section{Math}

\subsection{Basic Arithmetic}
\lstinputlisting{src/math/basic-arithmetic.cpp}

\subsection{Sieve Methods : Prime, Divisor, Euler phi}
\lstinputlisting{src/math/sieve.cpp}

\subsection{Primality Test}
\lstinputlisting{src/math/primality-test.cpp}

\subsection{Chinese Remainder Theorem}
\lstinputlisting{src/math/chinese-remainder.cpp}

\subsection{Burnside's Lemma}

경우의 수를 세는데, 특정 transform operation(회전, 반사, ..)해서 같은 경우들은 하나로 친다.
전체 경우의 수는?

- 각 operation마다 이 operation을 했을 때 변하지 않는 경우의 수를 센다
(단, ``아무것도 하지 않는다''라는 operation도 있어야 함!)

- 전체 경우의 수를 더한 후, operation의 수로 나눈다. (답이 맞다면 항상 나누어 떨어져야 한다)

\subsection{Kirchoff's Theorem}

그래프의 스패닝 트리의 개수를 구하는 정리.

무향 그래프의 Laplacian matrix $L$를 만든다. 이것은 (정점의 차수 대각 행렬) - (인접행렬)이다.
$L$에서 행과 열을 하나씩 제거한 것을 $L'$라 하자. 어느 행/열이든 관계 없다.
그래프의 스패닝 트리의 개수는 $det(L')$이다.

\subsection{Fast Fourier Transform}
\lstinputlisting{src/math/fft.cpp}

\subsection{Matrix Operations}

\subsection{Gaussian Elimination}

\subsection{Simplex Algorithm}


\section{Data Structure}

\subsection{Order statistic tree}
\lstinputlisting{src/data-structure/order-statistic-tree.cpp}

\subsection{Fenwick Tree}
\lstinputlisting{src/data-structure/fenwick-tree.cpp}

\subsection{Segment Tree with Lazy Propagation}
\lstinputlisting{src/data-structure/segtree-lazyprop.cpp}

\subsection{Persistent Segment Tree}

\subsection{Link/Cut Tree}


\section{DP}

\subsection{Convex Hull Optimization}

$O(n^{2}) \to O(n\log{n})$

조건 1) DP 점화식 꼴

$D[i] = \min_{j<i}( D[j] + b[j] * a[i] )$

조건 2) $b[j] \leq b[j+1]$

특수조건) $a[i] \leq a[i+1]$ 도 만족하는 경우, 마지막 쿼리의 위치를 저장해두면 이분검색이 필요없어지기 때문에 amortized $O(n)$ 에 해결할 수 있음

\subsection{Divide \& Conquer Optimization}

$O(kn^{2}) \to O(kn\log{n})$

조건 1) DP 점화식 꼴

$D[t][i] = \min_{j<i}( D[t-1][j] + C[j][i] )$

조건 2) $A[t][i]$는 $D[t][i]$의 답이 되는 최소의 $j$라 할 때, 아래의 부등식을 만족해야 함

$A[t][i] \leq A[t][i+1]$

조건 2-1) 비용$C$가 다음의 사각부등식을 만족하는 경우도 조건 2)를 만족하게 됨

$C[a][c] + C[b][d] \leq C[a][d] + C[b][c] \phantom{1} (a \leq b \leq c \leq d)$

\subsection{Knuth Optimization}

$O(n^{3}) \to O(n^{2})$

조건 1) DP 점화식 꼴

$D[i][j] = \min_{i<k<j}( D[i][k] + D[k][j] ) + C[i][j]$

조건 2) 사각 부등식

$C[a][c] + C[b][d] \leq C[a][d] + C[b][c] \phantom{1} (a \leq b \leq c \leq d)$

조건 3) 단조성

$C[b][c] \leq C[a][d] \phantom{1} (a \leq b \leq c \leq d)$

결론) 조건 2, 3을 만족한다면  $A[i][j]$를 $D[i][j]$의 답이 되는 최소의 $k$라 할 때, 아래의 부등식을 만족하게 됨

$A[i][j-1] \leq A[i][j] \leq A[i+1][j]$

3중 루프를 돌릴 때 위 조건을 이용하면 최종적으로 시간복잡도가 $O(n^{2})$ 이 됨

\section{Graph}

\subsection{SCC (Tarjan)}

\subsection{SCC (Kosaraju)}
\lstinputlisting{src/graph/scc-kosaraju.cpp}

\subsection{2-SAT}

$(b_{x} \lor b_{y}) \land (\neg b_{x} \lor b_{z}) \land (b_{z} \lor \neg b_{x}) \land \cdots$ 같은 form을 2-CNF라고 함. 주어진 2-CNF 식을 참으로 하는 $\{ b_1, b_2, \cdots \}$ 가 존재하는지, 존재한다면 그 값은 무엇인지 구하는 문제를 2-SAT이라 함.

boolean variable $b_{i}$ 마다 $b_{i}$를 나타내는 정점, $\neg b_{i} $를 나타내는 정점 2개를 만듦. 각 clause $b_{i} \lor b_{j}$ 마다 $\neg b_{i} \to b_{j}$, $\neg b_{j} \to b_{i}$ 이렇게 edge를 이어줌. 그렇게 만든 그래프에서 SCC를 다 구함. 어떤 SCC 안에 $b_{i}$ 와 $\neg b_{i}$가 같이 포함되어있다면 해가 존재하지 않음. 아니라면 해가 존재함.

해가 존재할 때 구체적인 해를 구하는 방법. 위에서 SCC를 구하면서 SCC DAG를 만들어준다. 거기서 위상정렬을 한 후, 앞에서부터 SCC를 하나씩 봐준다. 현재 보고있는 SCC에 $b_{i}$가 속해있는데 얘가 $\neg b_{i}$보다 먼저 등장했다면 $b_{i} = \mathrm{false}$, 반대의 경우라면 $b_{i} = \mathrm{true}$, 이미 값이 assign되었다면 pass.

\subsection{BCC, Cut vertex, Bridge}
\lstinputlisting{src/graph/bcc.cpp}

\subsection{Lowest Common Ancestor}
\lstinputlisting{src/graph/lca.cpp}

\subsection{Heavy-Light Decomposition}

\subsection{Bipartite Matching (Hopcroft-Karp)}
\lstinputlisting{src/graph/bipartite-matching-hopcroft.cpp}

\subsection{Maximum Flow (Dinic)}
\lstinputlisting{src/graph/maxflow-dinic.cpp}

\subsection{Min-cost Maximum Flow}


\section{Geometry}

\subsection{Basic Operations}

\subsection{Compare angles}

\subsection{Convex Hull}
\lstinputlisting{src/geometry/convex-hull.cpp}

\subsection{Polygon Cut}

\subsection{Pick's theorem}

격자점으로 구성된 simple polygon이 주어짐. $i$는 polygon 내부의 격자점 수, $b$는 polygon 선분 위 격자점 수, $A$는 polygon의 넓이라고 할 때, 다음과 같은 식이 성립한다.

$A = i + \frac{b}{2} - 1$

\section{String}

\subsection{KMP}
\lstinputlisting{src/string/kmp.cpp}

\subsection{Aho-Corasick}
\lstinputlisting{src/string/aho-corasick.cpp}

\subsection{Suffix Array with LCP}

\subsection{Suffix Tree}

\subsection{Manacher's Algorithm}
\lstinputlisting{src/string/manacher.cpp}


\section{Miscellaneous}

\subsection{Fast I/O}
\lstinputlisting{src/miscellaneous/fastio.cpp}

\subsection{Magic Numbers}

\end{document}
